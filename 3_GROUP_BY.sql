--GROUP BY, HAVING
--GROUP BY : 그룹함수에 대해서 컬럼을 그룹으로 묶고자 할 때

SELECT DEPT_CODE, SUM(SALARY)연봉합 --DEPT CODE는 결과 23개, SUM은 결과 1개. 오류 발생
FROM EMPLOYEE
GROUP BY DEPT_CODE
ORDER BY DEPT_CODE;

--EMPLOYEE테이블에서 부서코드 별 그룹을 지정하여 
--부서코드, 그룹별 급여 합계, 그룹별 급여 평균, 인원 수 조회하기(부서코드 순으로 정렬)
SELECT DEPT_CODE, SUM(SALARY), CEIL(AVG(SALARY)),COUNT(EMP_NO)인원수  --COUNT(*)이미 부서별로 모여있어서ㅓ 모두 세준다는 의미로 *해주면됨
FROM EMPLOYEE
GROUP BY DEPT_CODE
ORDER BY DEPT_CODE;

--EMPLOYEE테이블에서 부서코드와 보너스를 받는 사원 수 조회 (부서코드 순으로 정렬)
SELECT DEPT_CODE, COUNT(BONUS)  --COUNT는 NULL첨부터 배제함
FROM EMPLOYEE
GROUP BY DEPT_CODE
ORDER BY DEPT_CODE;

--EMPLOYEE테이블에서 직급코드와 보너스를 받는 사원 수 조회 (직급코드 순으로 정렬)
--COUNT가 0인 직급코드는 제외
SELECT JOB_CODE, COUNT(BONUS)
FROM EMPLOYEE
WHERE BONUS IS NOT NULL
GROUP BY JOB_CODE
ORDER BY JOB_CODE;

--EMPLOYEE테이블에서 성별과 성별 별 급여 평균, 급여합계, 인원 수 조회 (인원수로 내림차순)
SELECT DECODE(SUBSTR(EMP_NO,INSTR(EMP_NO,'-')+1, 1),1,'남',2, '여') 성별, CEIL(AVG(SALARY))"급여 평균" ,SUM(SALARY)"급여 합계", COUNT(*)"인원 수"
FROM EMPLOYEE
GROUP BY SUBSTR(EMP_NO,INSTR(EMP_NO,'-')+1, 1)
ORDER BY "인원 수"  DESC;


--부서 코드 별로 같은 직급인 사원의 급여합계
SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE, JOB_CODE --기준을 여러 개 만들기
ORDER BY DEPT_CODE;

--HAVING : 그룹함수에 대한 조건 설정
-- 부서코드와 급여 3000000이상인 직원의 그룹별 평균 급여조회
SELECT DEPT_CODE, CEIL(AVG(SALARY))
FROM EMPLOYEE
WHERE SALARY >= 3000000
GROUP BY DEPT_CODE
ORDER BY DEPT_CODE ;


--부서코드와 급여평균이 300만 이상인 그룹을 조회해보기
SELECT DEPT_CODE, CEIL(AVG(SALARY))
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING AVG(SALARY) >= 3000000
ORDER BY DEPT_CODE;

--부서 별 그룹의 급여 합계 중 9백만을 초과하는 부서코드와 급여합계 조회
SELECT DEPT_CODE,SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING SUM(SALARY) > 9000000;


--집합 연산자
--UNION : 합집합
--INTERSECT : 교집합
--UNION ALL : 합집합 + 교집합 (교집합이 두번들어가게댐)
--MINUS : 차집합 A-B = AUB-A^B

--DEPT_CODE가 D5인 사원의 사번, 이름, 부서코드 , 급여 조회
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'; --6개




--급여가 300만을 초과하는 사원의 사번, 이름 , 부서코드 , 급여 조회
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000; --8개

--<1>UNION == OR 시키기.
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE 
WHERE SALARY > 3000000;  --12개 행


--<2>INTERSECT : 교집합
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
INTERSECT
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE 
WHERE SALARY > 3000000;  --2 (D5이면서 AND 300초과인)

--UNION ALL
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION ALL
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE 
WHERE SALARY > 3000000; --14개. (12 + 2 ,중복된 데이터까지 다 나옴)


--MINUS 차집합
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
MINUS
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE 
WHERE SALARY > 3000000; --4개 (D5이면서 300이하인 사람들.)

--이때 SELECT 컬럼명은 다 같지 않아도 됨.대신 개수와 타입은 같아야함 !


--<JOIN>
--하나 이상의 테이블에서 데이터를 조회하기 위해 사용되고 수행결과는 하나의RESULT SET으로 나옴.
--내가 날 조인할수도잇음(셀프조인 ,자가조인 등)컬럼명보고 조인하는게 X 데이터를 보고 같으면 JOIN
SELECT EMP_ID, EMP_NAME, DEPT_CODE
FROM EMPLOYEE;
