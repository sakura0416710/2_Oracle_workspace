--DML (INSERT, UPDATE, DELETE) : 데이터 조작 언어
--TRANSACTION (COMMIT, ROLLBACK)을 꼭 적어주기
--DML -> DDL(CREATE,DELETE, ALTER)하고 나면 자동커밋 됨 (DML에 있는 정보도 확정되므로 순서 유의할 것)

--<1>INSERT (테이블에 정보추가하기)
INSERT INTO EMPLOYEE 
VALUES (900, '강건강', '990999-191212', 'kang_kk@kh.co.kr','01012341234','D1','J1','S3',
        3000000,0.2,200,SYSDATE, NULL, 'N');
        
SELECT * FROM EMPLOYEE WHERE EMP_NAME = '강건강';

--(1)INSERT INTO 테이블명 VALUES (데이터1, 데이터2,...);
--(2)INSERT INTO 테이블명( 컬럼명1, 컬럼명2, 컬럼명3,...) VALUES (데이터1, 데이터2, 데이터3, ....);
--(1) : 테이블 컬럼 순서를 알고 맞춰서 넣어야 함. 무조건 컬럼 전체에 데이터 삽입가능
--(2) : (컬럼명,...)에 맞게 데이터 삽입 가능 , 지정한 컬럼에 데이터 삽입 >지정안한 컬럼에는자동으로 NULL/DEFAULT VALUE가 들어감

COMMIT;

--INSERT절에 서브쿼리 넣기
INSERT INTO CONS_NAME(
    SELECT EMP_ID, EMP_NAME, EMP_NO
    FROM EMPLOYEE
);

--SUB QUERY로 테이블 만들기 (기준을 정해서 그거 복붙+ 테이블 만들겟다)
CREATE TABLE EMPLOYEE_COPY AS SELECT * FROM EMPLOYEE; --EMPLOYEE를 복붙하겠다
--컬럼명이랑 NOT NULL 제약조건만 복사 가능함.

CREATE TABLE EMPLOYEE_COPY2
AS SELECT EMP_ID, EMP_NAME, SALARY, DEPT_TITLE, JOB_NAME
    FROM EMPLOYEE
        JOIN DEPARTMENT ON (DEPT_CODE= DEPT_ID)
        JOIN JOB USING (JOB_CODE);


--INSERT ALL
CREATE TABLE EMP_DEPT_D1
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
    FROM EMPLOYEE
    WHERE 1=0;
--결과가FALSE이므로 구조만 가져오고 정보는 넣지 않겠다라는 뜻

CREATE TABLE EMP_MANAGER
AS SELECT EMP_ID, EMP_NAME, MANAGER_ID
    FROM EMPLOYEE
    WHERE 1 = 0;

    
--INSERT, SUBQUERY로 테이블에 삽입하는 연습문제
--EMP_DEPT D1테이블에는 EMPLOYEE테이블에 있는 부서코드가 D1인 직원을 조회해서
--사번, 이름, 소속부서, 입사일 삽입
INSERT INTO EMP_DEPT_D1 (
    SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
    FROM EMPLOYEE
    WHERE DEPT_CODE = 'D1'
);

--EMP_MANAGER테이블에는 EMPLOYEE테이블에 있는 부서코드가 D1인 직원을 조회해서 (서브쿼리 - 기준)
--사번, 이름, 관리자 사번 삽입 (최종 목표)
INSERT INTO EMP_MANAGER(
    SELECT EMP_ID, EMP_NAME, MANAGER_ID
    FROM EMPLOYEE
    WHERE DEPT_CODE = 'D1'
);
ROLLBACK;

INSERT ALL INTO EMP_DEPT_D1 VALUES (EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE)
       INTO EMP_MANAGER VALUES (EMP_ID, EMP_NAME, MANAGER_ID)
    SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE, MANAGER_ID
    FROM EMPLOYEE
    WHERE DEPT_CODE = 'D1';

--<연습문제 2번>
--EMPLOYEE테이블의 입사일을 기준으로 2000년 1월 1일 이전에 입사한 사원의 정보는 
--EMP_OLD에 삽입. 그 이후에 입사하 사원은 EMP_NEW에 삽입
CREATE TABLE EMP_OLD
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
    FROM EMPLOYEE
    WHERE 1=0;

CREATE TABLE EMP_NEW
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
    FROM EMPLOYEE
    WHERE 1=0;

--경우가 나뉠 경우 WHEN ~ THEN  / WHEN THEN~ ELSE 로 경우 나눠주고 SELECT FROM 으로 INSERT해주기
INSERT ALL 
WHEN HIRE_DATE < '2000/01/01' THEN INTO EMP_OLD VALUES (EMP_ID, EMP_NAME, HIRE_DATE,SALARY)
WHEN HIRE_DATE >= '2000/01/01' THEN INTO EMP_NEW VALUES( EMP_ID, EMP_NAME, HIRE_DATE, SALARY)
SELECT EMP_ID, EMP_NAME, HIRE_DAE, SALARY
FROM EMPLOYEE;

COMMIT;
ROLLBACK;
--UPDATE
--UPDATE 테이블명 SET 컬럼명=바꿀값, 컬럼명-바꿀값, ... [WHERE조건];
--EMPLOYEE_COPY 테이블에서DEPT_CODE가 D9인 행의 SALARY를 0으로 수정

UPDATE EMPLOYEE_COPY SET SALARY=0
WHERE DEPT_CODE = 'D9';

SELECT * FROM EMPLOYEE_COPY WHERE EMP_NAME IN('유재식', '방명수');

--UPDATE에도 서브쿼리 가능하다
UPDATE EMPLOYEE_COPY 
SET SALARY =(SELECT SALARY FROM EMPLOYEE WHERE EMP_NAME = '유재식'),
    BONUS = (SELECT BONUS FROM EMPLOYEE WHERE EMP_NAME = '방명수')
WHERE EMP_NAME = '방명수';

--UPDATE에 다중열로 써주기
SELECT * FROM EMPLOYEE_COPY WHERE EMP_NAME IN ('유재식','노옹철','하동운','전형돈','정중하');

UPDATE EMPLOYEE_COPY 
SET (SALARY, BONUS) = (SELECT SALARY, BONUS FROM EMPLOYEE WHERE EMP_NAME = '유재식')
WHERE EMP_NAME IN ('노옹철', '하동운', '전형돈','정중하');

COMMIT;

UPDATE EMPLOYEE SET EMP_NAME = NULL;
--NOT NULL제약조건 위배하는 것. EMP_NAME에는 NOT NULL제약조건 걸려있음
UPDATE CONS_NAME SET TEST_DATA2 = '강건강';
--UNIQUE걸려있어서 업데이트 안댐 (근데 왜 난 되지;;)



--DELETE : DATA삭제
SELECT * FROM EMPLOYEE;
DELETE FROM EMPLOYEE WHERE EMP_NAME = '강건강';
ROLLBACK;

DELETE FROM USER_GRADE WHERE GRADE_CODE = 10; --자식레코드 있어서 삭제 안댄다함(삭제옵션 없는 경우는 삭제 안됨)
ALTER TABLE USER_FOREIGNKEY
DISABLE CONSTRAINT FK_UF_GC CASCADE; --제약조건 비활성화 시키기 -> 삭제 됨

SELECT * FROM USER_GRADE;
SELECT * FROM USER_FOREIGNKEY;

ROLLBACK;

ALTER TABLE USER_FOREIGNKEY 
ENABLE CONSTRAINT FK_UF_GC; --재활성시키기 ->삭제불가

COMMIT;




SELECT * FROM EMP_DEPT_D1;
DELETE FROM EMP_DEPT_D1; --전체 삭제하겠다
ROLLBACK; --다시 살아남
 
TRUNCATE TABLE EMP_DEPT_D1; --Table EMP_DEPT_D1이(가) 잘렸습니다.
ROLLBACK;

TRUNCATE TABLE EMP_DEPT_D1; 
--TRUNCATE : 테이블의 전체 행 삭제
--ROLLBACK을 통해 복구 불가. DELETE보다 수행속도가 빠르다.


