--DDL(CREATE)
--CREATE: 테이블이나 인덱스, 뷰 등 데베 객체를 생성하는 구문
--CREATE TABLE 테이블명 (컬렴명 자료형(크키) ... );
--데이터 타입
--문자 : CHAR(고정길이의 문자열 저장 2000바이트), VARCHAR2(가변길이의 문자열 저장 4000바이트)
--크기지정 시 기본적으로 BYTE로 지정됨. CHAR로 명시해서 크기지정도 가능.
--CHAR (3CHAR) : 3글자가 들어가게 지정
--EX. ABC, 123, 박신우 (한글은 1글자당 3바이트)
--CHAR VS VARCHAR2
--EX. CHAR(10 CHAR) : 안녕하세요 _ _ _ _ _
--EX. VARCHAR2 (10CHAR) : 안녕하세요
--숫자 : NUMBER
--날짜 : DATE

--CREATE : 객체를 생성하는 구문
CREATE TABLE MEMBER (
    MEMBER_ID VARCHAR2 (20),
    MEMBER_PWD VARCHAR2(20),
    MEMBER_NAME VARCHAR2 (20)
);

COMMENT ON COLUMN MEMBER.MEMBER_ID IS '회원 아이디';
COMMENT ON COLUMN MEMBER.MEMBER_PWD IS '비밀번호';
COMMENT ON COLUMN MEMBER.MEMBER_NAME IS '회원 이름';


--제약조건 : 테이블 작성 시 각 컬럼에 대해 값 기록에 대한 제약조건 설정 가능
--데이터 무결성 보장을 목적으로 함
--데이터 무결성: 정확성, 일관성,유효성이 유지되는 것
--입력.수정,삭제 데이터에 문제가 없는지 자동으로 검사
--제약조건 : 테이블을 처음 만들 때 지정하거나 다 만들고 나서 지정해도 됨
--<1>NOT NULL : 컬럼에 반드시 값이 기록되어야 하는 경우 사용
CREATE TABLE USER_NOCONST (
    USER_NO NUMBER,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30),
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2 (50)
);
INSERT INTO USER_NOCONST VALUES (1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222','kang123@kh.co.kr');
INSERT INTO USER_NOCONST VALUES (NULL,NULL,NULL,NULL,NULL,NULL,NULL);

--NOT NULL : 컬럼 레벨에서만 제약조건을 설정가능
CREATE TABLE USER_NOTNULL (
    USER_NO NUMBER NOT NULL, 
    USER_ID VARCHAR2(20)NOT NULL,
    USER_PWD VARCHAR2(30)NOT NULL,
    USER_NAME VARCHAR2(30)NOT NULL,
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2 (50)
);
INSERT INTO USER_NOTNULL VALUES (1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222','kang123@kh.co.kr');
INSERT INTO USER_NOTNULL VALUES (2,'user0', 'pass02', '남나눔','남','010-1212-1111', 'nam123@kh.co.kr' );

--UNIQUE : 컬럼 값에 대해 중복을 제한하는 제약조건(컬럼레벨,
CREATE TABLE USER_UNIQUE (
    USER_NO NUMBER UNIQUE, --컬럼레벨에서 제약조건 설정하기
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30),
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2 (50),
    UNIQUE(USER_ID) --테이블레벨에서 제약조건 설정하기
);
INSERT INTO USER_UNIQUE VALUES (1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222','kang123@kh.co.kr');
INSERT INTO USER_UNIQUE VALUES (2, 'USER02', 'PASS01', '강건강', '남', '010-1111-2222','kang123@kh.co.kr');
--무결성 제약조건에 위배된다고 뜸 SYS_C007320이 제약조건 명

SELECT UCC.TABLE_NAME, UCC.COLUMN_NAME, UC.CONSTRAINT_TYPE
FROM USER_CONSTRAINTS UC, USER_CONS_COLUMNS UCC
WHERE UCC.CONSTRAINT_NAME = UC.CONSTRAINT_NAME
    AND UCC.CONSTRAINT_NAME = 'SYS_C007320';

CREATE TABLE USER_UNIQUE2 (
    USER_NO NUMBER,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30),
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2 (50),
    UNIQUE(USER_NO, USER_ID) --따로따로 적용안되고 쌍으로 같지 않아야 들어감
);
INSERT INTO USER_UNIQUE22 VALUES (1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222','kang123@kh.co.kr');
INSERT INTO USER_UNIQUE VALUES (2, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222','kang123@kh.co.kr');
INSERT INTO USER_UNIQUE2 VALUES (1, 'USER02', 'PASS01', '강건강', '남', '010-1111-2222','kang123@kh.co.kr');
INSERT INTO USER_UNIQUE2 VALUES (2, 'USER02', 'PASS01', '강건강', '남', '010-1111-2222','kang123@kh.co.kr');

--무결성 제약조건 이름짓기
CREATE TABLE CONS_NAME (
    TEST_DATA1 VARCHAR2(20)CONSTRAINT NN_CN_TD1 NOT NULL,--제약조건_테이블명_컬럼명
    TEST_DATA2 VARCHAR2(20)CONSTRAINT UQ_CN_TD2 UNIQUE ,
    TEST_DATA3 VARCHAR2(20),
    CONSTRAINT UQ_CN_TD3 UNIQUE(TEST_DATA3)
);
INSERT INTO CONS_NAME VALUES ('TEST1','TEST2','TEST3');

SELECT *
FROM USER_CONSTRAINT C1
    JOIN USER_CONS_COLUMN C2 USING(CONSTRAINT_NAME)
WHERE C1.TABLE_NAME = 'CONS_NAME';

--PRIMARY KEY : NOT NULL제약조건 + UNIQUE제약 합친 거
--테이블에 대한 식별자 역할을 할 수 있도록 도와줌 / 한 테이블당 한개로 설정
--PRIMARY KEY를 설정하면 얘 갖고있는 인덱스가 따라와서 따로 인덱스 설정 안해도 어느정도 좋음

CREATE TABLE USER_PRIMARYKEY (
    USER_NO NUMBER CONSTRAINT PK_UP_NO PRIMARY KEY, --컬럼 레벨에 저장
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30),
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2 (50)
);
INSERT INTO USER_PRIMARYKEY VALUES (1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222','kang123@kh.co.kr');
INSERT INTO USER_PRIMARYKEY VALUES (1, 'NULL', 'PASS01', '강건강', '남', '010-1111-2222','kang123@kh.co.kr');

CREATE TABLE USER_PRIMARYKEY2 (
    USER_NO NUMBER,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30),
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2 (50),
    CONSTRAINT PK_UP_NOID PRIMARY KEY(USER_NO, USER_ID)
);
INSERT INTO USER_PRIMARY2 VALUES (1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222','kang123@kh.co.kr');
INSERT INTO USER_PRIMARY2 VALUES (2, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222','kang123@kh.co.kr');
INSERT INTO USER_PRIMARY2 VALUES (1, 'USER02', 'PASS01', '강건강', '남', '010-1111-2222','kang123@kh.co.kr');
INSERT INTO USER_PRIMARY2 VALUES (2, 'USER02', 'PASS01', '강건강', '남', '010-1111-2222','kang123@kh.co.kr');

--FOREIGN KEY :참조하고 있는 다른 테이블의 컬럼이 제공하는 값만 사용하게 하는 제약조건
--테이블 간의 관계가 형성됨, 참조하는 컬럼은 PRIMARY KEY/UNIQUE가 들어간 컬럼만 참조가능하다.
CREATE TABLE USER_GRADE (
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);
INSERT INTO USER_GRADE VALUES (10, '우수회원');
INSERT INTO USER_GRADE VALUES (20, '우수회원');
INSERT INTO USER_GRADE VALUES (30, '특별회원');


CREATE TABLE USER_FOREIGNKEY (
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30)NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2 (50),
    GRADE_CODE NUMBER CONSTRAINT FK_UF_GC REFERENCES USER_GRADE(GRADE_CODE)--컬럼레벨에서 외래키 제약조건 넣기
);

INSERT INTO USER_FOREIGNKEY VALUES (1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222','kang123@kh.co.kr', 10);
INSERT INTO USER_FOREIGNKEY VALUES (2, 'USER02', 'PASS02', '남나눔', '남', '010-3333-4444','NAM123@kh.co.kr', 10);
INSERT INTO USER_FOREIGNKEY VALUES (3, 'USER03', 'PASS03', '도대남', '남', '010-5555-6666','DOH123@kh.co.kr', 30);
INSERT INTO USER_FOREIGNKEY VALUES (4, 'USER04', 'PASS04', '유라라', '여', '010-7777-8888','RYU123@kh.co.kr', NULL);
--NULL넣으면 참조를 안하겠다는 뜻이 됨
INSERT INTO USER_FOREIGNKEY VALUES (5, 'USER05', 'PASS05', '문미미', '여', '010-9999-0000','mimi123@kh.co.kr', 50);
--부모값 없다고 안됨

COMMIT;
--상태 확정 / 상태 되돌리기 ROLLBACK (마지막으로 커밋한 시점)
--DELETE 데이터 삭제
DELETE FROM USER_GRADE
WHERE GRADE_CODE = 20;

DELETE FROM USER_GRADE
WHERE GRADE_CODE = 10; --자식 참조가 있기 때문에 맘대로 삭제 불가

ROLLBACK; --마지막커밋 시점으로 돌아감


--삭제옵션
CREATE TABLE USER_GRADE2 (
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);
INSERT INTO USER_GRADE2 VALUES (10, '우수회원');
INSERT INTO USER_GRADE2 VALUES (20, '우수회원');
INSERT INTO USER_GRADE2 VALUES (30, '특별회원');


CREATE TABLE USER_FOREIGNKEY2 (
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30)NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2 (50),
    GRADE_CODE NUMBER, 
    CONSTRAINT FK_UF2_GC FOREIGN KEY(GRADE_CODE) REFERENCES USER_GRADE2(GRADE_CODE)ON DELETE SET NULL 
    --제약조건명 + 테이블레벨에서 참조하기 + 삭제옵션까지 추가
    --ON DELETE SET NULL : 부모키 삭제 시 자식키를 NULL로 변경해줌.
);

INSERT INTO USER_FOREIGNKEY2 VALUES (1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222','kang123@kh.co.kr', 10);
INSERT INTO USER_FOREIGNKEY2 VALUES (2, 'USER02', 'PASS02', '남나눔', '남', '010-3333-4444','NAM123@kh.co.kr', 10);
INSERT INTO USER_FOREIGNKEY2 VALUES (3, 'USER03', 'PASS03', '도대남', '남', '010-5555-6666','DOH123@kh.co.kr', 30);
INSERT INTO USER_FOREIGNKEY2 VALUES (4, 'USER04', 'PASS04', '유라라', '여', '010-7777-8888','RYU123@kh.co.kr', NULL);

COMMIT;

SELECT * FROM USER_GRADE2;
SELECT * FROM USER_FOREIGNKEY2;

DELETE FROM USER_GRADE2
WHERE GRADE_CODE = 10; --이제 삭제됨.

ROLLBACK;

--<DELETE 두번째 - ON DELETE CASCADE : 부모키 삭제 시 그걸 참조하는 자식키도 전부 삭제 됨.>
CREATE TABLE USER_GRADE3 (
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);
INSERT INTO USER_GRADE3 VALUES (10, '우수회원');
INSERT INTO USER_GRADE3 VALUES (20, '우수회원');
INSERT INTO USER_GRADE3 VALUES (30, '특별회원');


CREATE TABLE USER_FOREIGNKEY3 (
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30)NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2 (50),
    GRADE_CODE NUMBER, 
    CONSTRAINT FK_UF3_GC FOREIGN KEY(GRADE_CODE) REFERENCES USER_GRADE3(GRADE_CODE)ON DELETE CASCADE
    
);

INSERT INTO USER_FOREIGNKEY3 VALUES (1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222','kang123@kh.co.kr', 10);
INSERT INTO USER_FOREIGNKEY3 VALUES (2, 'USER02', 'PASS02', '남나눔', '남', '010-3333-4444','NAM123@kh.co.kr', 10);
INSERT INTO USER_FOREIGNKEY3 VALUES (3, 'USER03', 'PASS03', '도대남', '남', '010-5555-6666','DOH123@kh.co.kr', 30);
INSERT INTO USER_FOREIGNKEY3 VALUES (4, 'USER04', 'PASS04', '유라라', '여', '010-7777-8888','RYU123@kh.co.kr', NULL);

COMMIT;

SELECT * FROM USER_GRADE3;
SELECT * FROM USER_FOREIGNKEY3;

DELETE FROM USER_GRADE3 WHERE GRADE_CODE = 10; 

ROLLBACK;


--<CHECK -컬럼에 기록되는 값에 대해 범위조건 설정>
CREATE TABLE USER_CHECK (
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10)CHECK(GENDER IN ('남', '여')),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2 (50)
);
INSERT INTO USER_CHECK VALUES (1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222','kang123@kh.co.kr');
INSERT INTO USER_CHECK VALUES (2, 'USER02', 'PASS02', '남나눔', '남자', '010-3333-4444','NAM123@kh.co.kr');
--체크 제약 조건에 위배됨 (남 아님 여만 가능하게 했으니까)

--CHECK로 범위설정하기(2)
CREATE TABLE USER_CHECK2(
    C_NAME VARCHAR2 (15 CHAR),
    C_PRICE NUMBER CONSTRAINT CK_UC2_PRICE CHECK(C_PRICE >=1 AND C_PRICE <= 99999),
 --   C_PRICE NUMBER CONSTRAINT CK_UC2_PRICE CHECK(C_PRICE BETWEEN 1 AND 99999),
    C_LEVEL CHAR(1),
    C_DATE DATE,
    CONSTRAINT CK_UC2_LEVEL CHECK (C_LEVEL = 'A' OR C_LEVEL = 'B' OR C_LEVEL = 'C'),
    CONSTRAINT CK_UC2_DATE  CHECK (C_DATE >= TO_DATE('2020/01/01', 'YYYY/MM/DD'))
);


/*CHECK 실습문제
회원가입용 테이블 생성 : USER_TEST
컬럼명 
    USER_NO(회원번호)       :NUMBER         - 기본키(PK_UT_USERNO)
    USER_ID (회원아이디)    : VARCHAR2(20)  - 중복금지 (UQ_UT_USERID)
    USER_PWD(회원 비밀번호) : VARCHAR2(20)   - NULL허용X(NN_UT_USERPWD)
    PNO (주민등록번호)      : VARCHAR2(20)   - 중복금지(UQ_UT_PNO), NULL허용안함 (NN_UT_PNO)
    GENDER (성별)          : VARCHAR2(3)   - 남 혹은 여로 입력 (CK_UT_GENDER)
    PHONE (연락처)         : VHRCHAR2(20) 
    ADDRESS (주소)         : VARCHAR2(100)
    STATUS (탈퇴여부)       : VARCHAR2(3)     -NULL허용안함 (NN_UT_STATUS), Y또는N으로 입력 (CK_UT_STATUS)
    *각 컬럼에 제약조건이 있으면 제약조건을 넣고 제약조건의 이름까지 부여
    *컬럼 주석 넣기 (소괄호 내용 활용)
    *5명 이상 INSERT하기
    
*/ 
--CONSTRAINT가 여러개면 NULL같이 컬럼에만 들어가는 제약어 빼고 테이블 제약어로 넣음
CREATE TABLE USER_TEST (
    USER_NO NUMBER CONSTRAINT PK_UT_USERNO PRIMARY KEY,
    USER_ID VARCHAR2(20) CONSTRAINT UQ_UT_USERID UNIQUE,
    USER_PWD VARCHAR2(20) CONSTRAINT NN_UT_USERPWD NOT NULL,
    PNO VARCHAR2(20) CONSTRAINT NN_UT_PNO NOT NULL,
    GENDER VARCHAR2(3) CONSTRAINT CK_UT_GENDER CHECK(GENDER IN ('남','여')),
    PHONE VARCHAR2(20),
    ADDRESS  VARCHAR2(100),
    STATUS VARCHAR2(3)CONSTRAINT NN_UT_STATUS NOT NULL,
    CONSTRAINT UQ_UT_PNO UNIQUE(PNO),
    CONSTRAINT CK_UT_STATUS CHECK(STATUS IN('Y','N'))

);
--테이블 생성 컬럼 별칭달기
COMMENT ON COLUMN USER_TEST.USER_NO IS '회원번호';
COMMENT ON COLUMN USER_TEST.USER_ID IS '회원아이디';
COMMENT ON COLUMN USER_TEST.USER_PWD IS '회원비밀번호';
COMMENT ON COLUMN USER_TEST.PNO IS '주민번호';
COMMENT ON COLUMN USER_TEST.GENDER IS '성별';
COMMENT ON COLUMN USER_TEST.PHONE IS '핸드폰번호';
COMMENT ON COLUMN USER_TEST.ADDRESS IS '주소';
COMMENT ON COLUMN USER_TEST.STATUS IS '탈퇴여부';

INSERT INTO USER_TEST VALUES (1,'kim01','1234','001211-1112323','남','010-1111-2222','서울시 관악구','Y');
INSERT INTO USER_TEST VALUES (2,'kim02','5678','002341-1342323','남','010-3411-2222','강원도 춘천','N');
INSERT INTO USER_TEST VALUES (3,'lee03','9012','001211-1124232','여','010-1761-2332','부산광역시 동래구','N');
INSERT INTO USER_TEST VALUES (4,'lee04','3456','001211-1888388','여','010-1751-2292','강원도 속초','N');
INSERT INTO USER_TEST VALUES (5,'kang05','7809','001211-8883888','남','010-1121-2622','전라도 익산','Y');











